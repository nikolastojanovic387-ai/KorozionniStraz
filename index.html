<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipeline Inhibitor Tube Assembly</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            transition: background 0.5s ease;
        }
        body.white-bg {
            background: #ffffff;
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            max-width: 180px;
            font-size: 11px;
            z-index: 100;
        }
        .white-bg .controls {
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .controls h3 {
            margin: 0 0 10px 0;
            color: #1e3c72;
            font-size: 13px;
        }
        .white-bg .controls h3 {
            color: #2a5298;
        }
        .control-group {
            margin: 8px 0;
        }
        .control-group label {
            display: block;
            margin-bottom: 4px;
            color: #333;
            font-size: 10px;
            font-weight: 600;
        }
        button {
            width: 100%;
            padding: 6px 8px;
            margin: 3px 0;
            border: none;
            border-radius: 4px;
            background: #2a5298;
            color: white;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            transition: all 0.3s;
        }
        button:hover {
            background: #1e3c72;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        button:active {
            transform: translateY(0);
        }
        .white-bg button {
            background: #2a5298;
        }
        .white-bg button:hover {
            background: #1e3c72;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 6px 0;
        }
        input[type="checkbox"] {
            width: 14px;
            height: 14px;
            cursor: pointer;
        }
        
        /* Background toggle switch */
        .bg-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 8px 0;
            padding: 6px 0;
        }
        .bg-toggle-label {
            font-size: 10px;
            color: #333;
            font-weight: 600;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-slider {
            background-color: #2a5298;
        }
        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }
        
        /* Zoom controls */
        .zoom-controls {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }
        .zoom-slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
        }
        .zoom-slider {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            background: #ddd;
            border-radius: 2px;
            outline: none;
        }
        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #2a5298;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .zoom-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #2a5298;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .zoom-value {
            font-size: 10px;
            color: #333;
            font-weight: 600;
            min-width: 30px;
            text-align: center;
        }
        .zoom-buttons {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }
        .zoom-buttons button {
            flex: 1;
            padding: 4px 6px;
            font-size: 9px;
        }
        
        .info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-size: 10px;
            color: #333;
            max-width: 180px;
            z-index: 100;
        }
        .white-bg .info {
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border: 1px solid #eee;
        }
        .info h4 {
            margin: 0 0 8px 0;
            color: #1e3c72;
            font-size: 12px;
        }
        .white-bg .info h4 {
            color: #2a5298;
        }
        .info p {
            margin: 3px 0;
            line-height: 1.4;
        }
        
        @media (max-width: 768px) {
            .controls {
                top: 5px;
                right: 5px;
                left: auto;
                max-width: 140px;
                padding: 8px;
                font-size: 9px;
            }
            .controls h3 {
                font-size: 11px;
                margin-bottom: 6px;
            }
            button {
                padding: 5px 6px;
                font-size: 9px;
                margin: 2px 0;
            }
            .control-group label {
                font-size: 9px;
            }
            input[type="checkbox"] {
                width: 12px;
                height: 12px;
            }
            .bg-toggle {
                margin: 6px 0;
                padding: 4px 0;
            }
            .bg-toggle-label {
                font-size: 9px;
            }
            .toggle-switch {
                width: 36px;
                height: 18px;
            }
            .toggle-slider:before {
                height: 14px;
                width: 14px;
                left: 2px;
                bottom: 2px;
            }
            input:checked + .toggle-slider:before {
                transform: translateX(18px);
            }
            .zoom-slider-container {
                gap: 6px;
            }
            .zoom-slider {
                height: 3px;
            }
            .zoom-slider::-webkit-slider-thumb {
                width: 14px;
                height: 14px;
            }
            .zoom-value {
                font-size: 9px;
                min-width: 25px;
            }
            .info {
                display: none;
            }
        }
        
        @media (max-width: 480px) {
            .controls {
                max-width: 120px;
                padding: 6px;
            }
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3>Управление 3D моделью</h3>
        <div class="control-group">
            <button id="showAll">Показать всё</button>
            <button id="showTubes">Трубы</button>
            <button id="showCaps">Заглушки</button>
            <button id="showCapsule">Капсула ингибитора</button>
        </div>
        <div class="control-group">
            <div class="checkbox-group">
                <input type="checkbox" id="toggleConnectors" checked>
                <label for="toggleConnectors">Показать кольца</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="toggleRotation" checked>
                <label for="toggleRotation">Авто-вращение</label>
            </div>
        </div>
        
        <!-- Background Toggle -->
        <div class="control-group">
            <div class="bg-toggle">
                <span class="bg-toggle-label">Белый фон</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="toggleBackground">
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
        
        <!-- Zoom Controls -->
        <div class="control-group zoom-controls">
            <label for="zoomSlider">Масштаб:</label>
            <div class="zoom-slider-container">
                <input type="range" id="zoomSlider" class="zoom-slider" min="100" max="4000" value="1200" step="50">
                <span id="zoomValue" class="zoom-value">1200</span>
            </div>
            <div class="zoom-buttons">
                <button id="zoomIn">+ Приблизить</button>
                <button id="zoomOut">- Отдалить</button>
            </div>
        </div>
        
        <div class="control-group">
            <button id="resetView">Сбросить камеру</button>
        </div>
    </div>
    
    <div class="info">
        <h4>Технические характеристики</h4>
        <p><strong>Трубы:</strong> 5x DN80, длина 1,5м, стенка 3мм</p>
        <p><strong>Кольца:</strong> 2x DN200, стенка 10мм</p>
        <p><strong>Резьба:</strong> 10мм на концах труб</p>
        <p><strong>Капсула:</strong> DN50, помещается внутрь</p>
        <p><strong>Отверстия:</strong> По 2 на трубу для прохода ингибитора</p>
        <p><strong>Применение:</strong> Система подачи твердого ингибитора</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, tubeGroup, capsGroup, connectorGroup, autoRotate = true;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotation = { x: 0, y: 0 };
        let capsuleManualRotation = false;
        
        // Zoom variables - Increased max zoom 4x (from 2000 to 4000)
        let zoomLevel = 1200;
        const minZoom = 100;
        const maxZoom = 4000; // Changed from 2000 to 4000 (4x more zoom out)
        const zoomStep = 100;
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 5000); // Increased far plane
            
            if (window.innerWidth < 768) {
                camera.position.set(600, 400, 1000);
                zoomLevel = 1000;
            } else {
                camera.position.set(800, 600, 1200);
                zoomLevel = 1200;
            }
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(500, 800, 600);
            directionalLight1.castShadow = true;
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-500, 400, -600);
            scene.add(directionalLight2);
            
            const pointLight = new THREE.PointLight(0x4a90e2, 0.5);
            pointLight.position.set(0, 500, 800);
            scene.add(pointLight);
            
            createModel();
            
            // Event listeners for mouse/touch controls
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseUp);
            renderer.domElement.addEventListener('click', onCanvasClick);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onTouchEnd);
            
            window.addEventListener('resize', onWindowResize);
            
            // Control event listeners
            document.getElementById('showAll').addEventListener('click', () => showView('all'));
            document.getElementById('showTubes').addEventListener('click', () => showView('tubes'));
            document.getElementById('showCaps').addEventListener('click', () => showView('caps'));
            document.getElementById('showCapsule').addEventListener('click', () => showView('capsule'));
            document.getElementById('resetView').addEventListener('click', resetCamera);
            document.getElementById('toggleConnectors').addEventListener('change', (e) => {
                connectorGroup.visible = e.target.checked;
            });
            document.getElementById('toggleRotation').addEventListener('change', (e) => {
                autoRotate = e.target.checked;
            });
            
            // Background toggle event listener
            document.getElementById('toggleBackground').addEventListener('change', (e) => {
                if (e.target.checked) {
                    document.body.classList.add('white-bg');
                    scene.background = new THREE.Color(0xffffff);
                } else {
                    document.body.classList.remove('white-bg');
                    scene.background = new THREE.Color(0x1a1a2e);
                }
            });
            
            // Zoom control event listeners
            const zoomSlider = document.getElementById('zoomSlider');
            const zoomValue = document.getElementById('zoomValue');
            const zoomInBtn = document.getElementById('zoomIn');
            const zoomOutBtn = document.getElementById('zoomOut');
            
            zoomSlider.value = zoomLevel;
            zoomValue.textContent = zoomLevel;
            
            zoomSlider.addEventListener('input', (e) => {
                zoomLevel = parseInt(e.target.value);
                updateZoom();
                zoomValue.textContent = zoomLevel;
            });
            
            zoomInBtn.addEventListener('click', () => {
                zoomLevel = Math.max(minZoom, zoomLevel - zoomStep);
                updateZoom();
                zoomSlider.value = zoomLevel;
                zoomValue.textContent = zoomLevel;
            });
            
            zoomOutBtn.addEventListener('click', () => {
                zoomLevel = Math.min(maxZoom, zoomLevel + zoomStep);
                updateZoom();
                zoomSlider.value = zoomLevel;
                zoomValue.textContent = zoomLevel;
            });
            
            animate();
        }
        
        function updateZoom() {
            // Calculate direction vector from camera to target
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.normalize();
            
            // Move camera along the direction vector based on zoom level
            const targetPosition = new THREE.Vector3(0, 0, 0);
            const distance = zoomLevel;
            
            camera.position.copy(targetPosition).sub(direction.multiplyScalar(distance));
            camera.lookAt(targetPosition);
        }
        
        function onMouseWheel(e) {
            e.preventDefault();
            
            // Adjust zoom level based on wheel direction
            if (e.deltaY < 0) {
                // Zoom in
                zoomLevel = Math.max(minZoom, zoomLevel - zoomStep * 2);
            } else {
                // Zoom out
                zoomLevel = Math.min(maxZoom, zoomLevel + zoomStep * 2);
            }
            
            // Update slider and value display
            document.getElementById('zoomSlider').value = zoomLevel;
            document.getElementById('zoomValue').textContent = zoomLevel;
            
            updateZoom();
        }
        
        function createModel() {
            const tubeMaterial = new THREE.MeshStandardMaterial({
                color: 0x708090,
                metalness: 0.8,
                roughness: 0.3
            });
            
            const connectorMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a4a4a,
                metalness: 0.9,
                roughness: 0.2
            });
            
            const capMaterial = new THREE.MeshStandardMaterial({
                color: 0x2c3e50,
                metalness: 0.85,
                roughness: 0.25
            });
            
            const threadMaterial = new THREE.MeshStandardMaterial({
                color: 0x606060,
                metalness: 0.7,
                roughness: 0.4
            });
            
            tubeGroup = new THREE.Group();
            capsGroup = new THREE.Group();
            connectorGroup = new THREE.Group();
            
            const tubeLength = 1500;
            const outerRadius = 88.9 / 2;
            const innerRadius = (88.9 - 6) / 2;
            const threadLength = 10;
            
            const angleStep = (Math.PI * 2) / 5;
            const centerRadius = outerRadius * 2.2;
            
            for (let i = 0; i < 5; i++) {
                const angle = i * angleStep;
                const x = Math.cos(angle) * centerRadius;
                const y = Math.sin(angle) * centerRadius;
                
                // Open-ended tube
                const tubeGeometry = new THREE.CylinderGeometry(
                    outerRadius, outerRadius, tubeLength, 32, 1, true
                );
                const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                tube.rotation.z = Math.PI / 2;
                tube.position.set(0, x, y);
                tube.castShadow = true;
                tube.receiveShadow = true;
                tubeGroup.add(tube);
                
                // Inner hollow
                const innerGeometry = new THREE.CylinderGeometry(
                    innerRadius, innerRadius, tubeLength, 32, 1, true
                );
                const inner = new THREE.Mesh(innerGeometry, new THREE.MeshStandardMaterial({
                    color: 0x0a0a0a,
                    side: THREE.BackSide,
                    metalness: 0.3,
                    roughness: 0.8
                }));
                inner.rotation.z = Math.PI / 2;
                inner.position.set(0, x, y);
                tubeGroup.add(inner);
                
                // Inhibitor capsules inside tube - FIXED: Properly spaced to not go through caps
                const capsuleInside = new THREE.Group();
                const capRadius = 50 / 2;
                const capLength = 180;
                const capsulesCount = 5; // Reduced to 5 to fit properly
                
                for (let k = 0; k < capsulesCount; k++) {
                    const capsuleGroup = new THREE.Group();
                    
                    for (let j = 0; j < 6; j++) {
                        const segLen = capLength / 6;
                        const segGeo = new THREE.CylinderGeometry(capRadius, capRadius, segLen, 16);
                        const segMat = new THREE.MeshStandardMaterial({
                            color: 0xffd700,
                            metalness: 0.5,
                            roughness: 0.4,
                            emissive: 0x554400,
                            emissiveIntensity: 0.2
                        });
                        const seg = new THREE.Mesh(segGeo, segMat);
                        seg.rotation.z = Math.PI / 2;
                        seg.position.x = -capLength/2 + segLen/2 + j * segLen;
                        capsuleGroup.add(seg);
                    }
                    
                    for (let j = 0; j < 3; j++) {
                        const rGeo = new THREE.TorusGeometry(capRadius + 1, 1, 6, 16);
                        const rMat = new THREE.MeshStandardMaterial({
                            color: 0x8b7500,
                            metalness: 0.9,
                            roughness: 0.1
                        });
                        const r = new THREE.Mesh(rGeo, rMat);
                        r.rotation.y = Math.PI / 2;
                        r.position.x = -capLength/2 + 30 + j * 60;
                        capsuleGroup.add(r);
                    }
                    
                    const endGeo = new THREE.SphereGeometry(capRadius, 12, 12, 0, Math.PI * 2, 0, Math.PI / 2);
                    const endMat = new THREE.MeshStandardMaterial({
                        color: 0xffd700,
                        metalness: 0.7,
                        roughness: 0.3
                    });
                    
                    const end1 = new THREE.Mesh(endGeo, endMat);
                    end1.rotation.z = -Math.PI / 2;
                    end1.position.x = -capLength/2;
                    capsuleGroup.add(end1);
                    
                    const end2 = new THREE.Mesh(endGeo, endMat);
                    end2.rotation.z = Math.PI / 2;
                    end2.position.x = capLength/2;
                    capsuleGroup.add(end2);
                    
                    // FIXED: Position capsules symmetrically without going through caps
                    const availableLength = tubeLength - 200; // Leave space for caps
                    const capsuleSpacing = availableLength / (capsulesCount + 1);
                    const startPos = -tubeLength/2 + 100 + capsuleSpacing;
                    const capsulePos = startPos + k * capsuleSpacing;
                    
                    capsuleGroup.position.set(capsulePos, x, y);
                    capsuleInside.add(capsuleGroup);
                }
                
                tubeGroup.add(capsuleInside);
                
                // Thread at beginning
                for (let j = 0; j < 5; j++) {
                    const threadRing = new THREE.TorusGeometry(outerRadius + 1, 1.5, 8, 16);
                    const thread1 = new THREE.Mesh(threadRing, threadMaterial);
                    thread1.rotation.y = Math.PI / 2;
                    thread1.position.set(-tubeLength/2 + j * 2.5, x, y);
                    tubeGroup.add(thread1);
                }
                
                // Thread at ending
                for (let j = 0; j < 5; j++) {
                    const threadRing = new THREE.TorusGeometry(outerRadius + 1, 1.5, 8, 16);
                    const thread2 = new THREE.Mesh(threadRing, threadMaterial);
                    thread2.rotation.y = Math.PI / 2;
                    thread2.position.set(tubeLength/2 - j * 2.5, x, y);
                    tubeGroup.add(thread2);
                }
                
                // Caps
                const capGeometry = new THREE.CylinderGeometry(
                    outerRadius + 3, outerRadius + 3, 15, 32
                );
                const cap1 = new THREE.Mesh(capGeometry, capMaterial);
                cap1.rotation.z = Math.PI / 2;
                cap1.position.set(-tubeLength/2 - 20, x, y);
                cap1.castShadow = true;
                capsGroup.add(cap1);
                
                const capTopGeometry = new THREE.CylinderGeometry(
                    0, outerRadius + 3, 10, 32
                );
                const capTop1 = new THREE.Mesh(capTopGeometry, capMaterial);
                capTop1.rotation.z = Math.PI / 2;
                capTop1.position.set(-tubeLength/2 - 27.5, x, y);
                capsGroup.add(capTop1);
                
                const cap2 = new THREE.Mesh(capGeometry, capMaterial);
                cap2.rotation.z = Math.PI / 2;
                cap2.position.set(tubeLength/2 + 20, x, y);
                cap2.castShadow = true;
                capsGroup.add(cap2);
                
                const capTop2 = new THREE.Mesh(capTopGeometry, capMaterial);
                capTop2.rotation.z = -Math.PI / 2;
                capTop2.position.set(tubeLength/2 + 27.5, x, y);
                capsGroup.add(capTop2);
                
                // Holes - simple black circles
                const holeRadius = 8;
                const outwardX = Math.cos(angle);
                const outwardY = Math.sin(angle);
                
                const hole1Pos = -tubeLength/2 + 50;
                const holeGeo = new THREE.CircleGeometry(holeRadius, 16);
                const holeMat = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    side: THREE.DoubleSide
                });
                
                const hole1 = new THREE.Mesh(holeGeo, holeMat);
                hole1.position.set(hole1Pos, x + outwardX * (outerRadius + 0.1), y + outwardY * (outerRadius + 0.1));
                hole1.rotation.z = -angle + Math.PI/2;
                tubeGroup.add(hole1);
                
                const hole2Pos = tubeLength/2 - 50;
                const hole2 = new THREE.Mesh(holeGeo, holeMat);
                hole2.position.set(hole2Pos, x + outwardX * (outerRadius + 0.1), y + outwardY * (outerRadius + 0.1));
                hole2.rotation.z = -angle + Math.PI/2;
                tubeGroup.add(hole2);
            }
            
            // FIXED: Create connector rings with gaps where they pass through tubes
            const connectorOuterRadius = 200 / 2;
            const connectorInnerRadius = (200 - 20) / 2;
            const connectorWidth = 30;
            
            function createConnectorRing(radius, width, positionX, isInner = false) {
                const ringGroup = new THREE.Group();
                
                // Define the 5 pipe positions (angles in radians)
                const pipeAngles = [0, 72, 144, 216, 288].map(deg => deg * Math.PI / 180);
                const pipeCoverage = Math.PI / 4; // Each pipe covers about 45 degrees
                
                // Create ring segments only in the gaps between pipes
                for (let i = 0; i < 5; i++) {
                    const gapStartAngle = pipeAngles[i] + pipeCoverage/2;
                    const gapEndAngle = pipeAngles[(i + 1) % 5] - pipeCoverage/2;
                    
                    // Ensure the gap angle is positive
                    let gapAngle = gapEndAngle - gapStartAngle;
                    if (gapAngle < 0) {
                        gapAngle += Math.PI * 2;
                    }
                    
                    // Create segment for this gap
                    const segmentGeometry = new THREE.TorusGeometry(
                        radius, width/2, 16, 32, 
                        gapStartAngle, gapAngle
                    );
                    
                    const material = isInner ? 
                        new THREE.MeshStandardMaterial({
                            color: 0x2a2a2a,
                            metalness: 0.9,
                            roughness: 0.3
                        }) : connectorMaterial;
                    
                    const segment = new THREE.Mesh(segmentGeometry, material);
                    segment.rotation.y = Math.PI / 2;
                    segment.position.x = positionX;
                    ringGroup.add(segment);
                }
                
                return ringGroup;
            }
            
            // Create outer connector rings (the big black rings)
            const outerRing1 = createConnectorRing(connectorOuterRadius, connectorWidth, -tubeLength/2 + 100);
            connectorGroup.add(outerRing1);
            
            const outerRing2 = createConnectorRing(connectorOuterRadius, connectorWidth, tubeLength/2 - 100);
            connectorGroup.add(outerRing2);
            
            // Create inner connector rings
            const innerRing1 = createConnectorRing(connectorInnerRadius, connectorWidth/2 - 2, -tubeLength/2 + 100, true);
            connectorGroup.add(innerRing1);
            
            const innerRing2 = createConnectorRing(connectorInnerRadius, connectorWidth/2 - 2, tubeLength/2 - 100, true);
            connectorGroup.add(innerRing2);
            
            // Separate capsule display
            const capsuleGroup = new THREE.Group();
            const capsuleRadius = 50 / 2;
            const capsuleLength = 200;
            
            for (let i = 0; i < 8; i++) {
                const segmentLength = capsuleLength / 8;
                const segmentMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffd700,
                    metalness: 0.5,
                    roughness: 0.4,
                    emissive: 0x554400,
                    emissiveIntensity: 0.3
                });
                
                const segmentGeometry = new THREE.CylinderGeometry(
                    capsuleRadius, capsuleRadius, segmentLength, 24
                );
                const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                segment.rotation.z = Math.PI / 2;
                segment.position.x = -capsuleLength/2 + segmentLength/2 + i * segmentLength;
                segment.castShadow = true;
                capsuleGroup.add(segment);
            }
            
            for (let i = 0; i < 4; i++) {
                const ringGeometry = new THREE.TorusGeometry(capsuleRadius + 2, 1.5, 8, 24);
                const ringMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8b7500,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.y = Math.PI / 2;
                ring.position.x = -capsuleLength/2 + 30 + i * 50;
                capsuleGroup.add(ring);
            }
            
            const endCapGeometry = new THREE.SphereGeometry(capsuleRadius, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const endCapMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                metalness: 0.7,
                roughness: 0.3
            });
            
            const capsuleEnd1 = new THREE.Mesh(endCapGeometry, endCapMaterial);
            capsuleEnd1.rotation.z = -Math.PI / 2;
            capsuleEnd1.position.x = -capsuleLength/2;
            capsuleGroup.add(capsuleEnd1);
            
            const capsuleEnd2 = new THREE.Mesh(endCapGeometry, endCapMaterial);
            capsuleEnd2.rotation.z = Math.PI / 2;
            capsuleEnd2.position.x = capsuleLength/2;
            capsuleGroup.add(capsuleEnd2);
            
            capsuleGroup.position.set(400, 200, 0);
            capsuleGroup.visible = false;
            
            const labelGeometry = new THREE.PlaneGeometry(150, 40);
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 256, 64);
            ctx.fillStyle = '#1e3c72';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Капсула DN50', 128, 28);
            ctx.fillText('с ингибитором', 128, 50);
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
            const infoLabel = new THREE.Mesh(labelGeometry, labelMaterial);
            infoLabel.position.set(0, -100, 0);
            capsuleGroup.add(infoLabel);
            
            scene.add(tubeGroup);
            scene.add(capsGroup);
            scene.add(connectorGroup);
            scene.add(capsuleGroup);
            
            window.capsuleGroup = capsuleGroup;
        }
        
        function showView(view) {
            tubeGroup.visible = false;
            capsGroup.visible = false;
            connectorGroup.visible = false;
            window.capsuleGroup.visible = false;
            
            tubeGroup.position.set(0, 0, 0);
            capsGroup.position.set(0, 0, 0);
            connectorGroup.position.set(0, 0, 0);
            
            switch(view) {
                case 'all':
                    tubeGroup.visible = true;
                    capsGroup.visible = true;
                    connectorGroup.visible = document.getElementById('toggleConnectors').checked;
                    break;
                case 'tubes':
                    tubeGroup.visible = true;
                    connectorGroup.visible = document.getElementById('toggleConnectors').checked;
                    break;
                case 'caps':
                    capsGroup.visible = true;
                    break;
                case 'capsule':
                    window.capsuleGroup.visible = true;
                    window.capsuleGroup.position.set(0, 0, 0);
                    break;
            }
        }
        
        function resetCamera() {
            if (window.innerWidth < 768) {
                zoomLevel = 1000;
            } else {
                zoomLevel = 1200;
            }
            
            // Update slider and value display
            document.getElementById('zoomSlider').value = zoomLevel;
            document.getElementById('zoomValue').textContent = zoomLevel;
            
            updateZoom();
            rotation.x = 0;
            rotation.y = 0;
        }
        
        function onMouseDown(e) {
            isDragging = true;
            previousMousePosition = {
                x: e.clientX,
                y: e.clientY
            };
        }
        
        function onCanvasClick(e) {
            if (window.capsuleGroup && window.capsuleGroup.visible) {
                capsuleManualRotation = !capsuleManualRotation;
            }
        }
        
        function onMouseMove(e) {
            if (isDragging) {
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };
                
                rotation.y += deltaMove.x * 0.005;
                rotation.x += deltaMove.y * 0.005;
                
                previousMousePosition = {
                    x: e.clientX,
                    y: e.clientY
                };
            }
        }
        
        function onMouseUp() {
            isDragging = false;
        }
        
        function onTouchStart(e) {
            if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            }
        }
        
        function onTouchMove(e) {
            if (isDragging && e.touches.length === 1) {
                e.preventDefault();
                const deltaMove = {
                    x: e.touches[0].clientX - previousMousePosition.x,
                    y: e.touches[0].clientY - previousMousePosition.y
                };
                
                rotation.y += deltaMove.x * 0.005;
                rotation.x += deltaMove.y * 0.005;
                
                previousMousePosition = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            }
        }
        
        function onTouchEnd() {
            isDragging = false;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (window.innerWidth < 768) {
                zoomLevel = 1000;
            } else {
                zoomLevel = 1200;
            }
            
            updateZoom();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotate && !isDragging) {
                rotation.x += 0.001;
                rotation.y += 0.0015;
            }
            
            tubeGroup.rotation.x = rotation.x;
            tubeGroup.rotation.y = rotation.y;
            capsGroup.rotation.x = rotation.x;
            capsGroup.rotation.y = rotation.y;
            connectorGroup.rotation.x = rotation.x;
            connectorGroup.rotation.y = rotation.y;
            
            if (window.capsuleGroup && window.capsuleGroup.visible) {
                if (!capsuleManualRotation) {
                    window.capsuleGroup.rotation.y += 0.005;
                } else {
                    if (isDragging) {
                        window.capsuleGroup.rotation.y = rotation.y * 2;
                        window.capsuleGroup.rotation.x = rotation.x * 2;
                    }
                }
            }
            
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>
